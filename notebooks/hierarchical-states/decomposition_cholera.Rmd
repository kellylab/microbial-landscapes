---
title: "Decomposition of states and time scales in human microbiomes recovering from cholera"
output: html_notebook
---

```{r setup}
library(dplyr)
library(data.table)
library(cowplot)
library(ggraph)
library(igraph)
source("utils.R")
knitr::opts_chunk$set(
  fig.path = "decomposition_nahant_figs/",
  fig.keep = "high",
  dev = c("pdf")
)
data.dir <- "../../data/"
gordon <- fread(paste0(data.dir, "cholera/gordon.otus"),
                col.names = c("sample", "otu", "count"))
# extract sample info
gordon.samples <- unique(gordon[, .(sample)])
# create a dummy 'sample index' to help remove reciprocal sample pairs later 
gordon.samples[, idx := 1:.N]
gordon.samples[, c("subject", "state", "id") := tstrsplit(sample, "_")]
gordon.samples[grep("d", id) & state == "recovery", time.unit := "day"]
gordon.samples[!grep("d", id), time.unit := "hour"]
gordon.samples[id == "end", time.unit := "hour"]
setkey(gordon.samples, time.unit)
gordon.samples["hour", hour := as.numeric(id)]
gordon.samples["day", hour := 24 * as.numeric(sub("d", "", id))]
subjects <- unique(gordon.samples$subject)
# set end hour to last hour + 1, days to end hour + 24 * days
gordon.samples[, hour := {
  maxhr <- max(.SD["hour"][id != "end"]$hour)
  endhr <- maxhr + 1
  hour[id == "end"] <- endhr
  hour[time.unit == "day"] <- hour[time.unit == "day"] + endhr
  hour
}, by = subject]
```

```{r}
# all samples vs all samples
gordon.div <- data.table(expand.grid(sample.i = gordon.samples$sample,
                                     sample.j = gordon.samples$sample)
                         )
# merge sample info
gordon.div <- merge(gordon.div, gordon.samples, by.x = "sample.i", 
                    by.y = "sample"
                    )
gordon.div <- merge(gordon.div, gordon.samples, by.x = "sample.j", 
                    by.y = "sample", suffixes = c(".i", ".j")
                    )
# remove inverse pairings
gordon.div <- gordon.div[idx.j >= idx.i]
# remove dummy variable
gordon.div[, ":=" (idx.i = NULL, idx.j = NULL)]
gordon[, log.count := log(count)]
gordon
setkey(gordon, sample)
gordon.div[, jsd := {
  if (sample.i == sample.j) {
    0
  } else{
    si <- sample.i
    sj <- sample.j
    sd <- gordon[c(si, sj)]
    m <- dcast(sd, otu ~ sample, value.var = "count")
    m <- as.matrix(m[, 2:3])
    m[is.na(m)] <- 0
    genJSD(m)
  }
}, by = .(sample.i, sample.j)]
inv <- gordon.div[sample.i != sample.j]
setnames(inv, names(inv), sapply(names(inv), function(x) {
  if (grepl("\\.i", x)) {
    gsub("\\.i", "\\.j", x)
  } else if (grepl("\\.j", x)) {
    gsub("\\.j", "\\.i", x)
  } else {
    x
  }
}))
gordon.div <- rbind(gordon.div, inv)
gordon.div[, distance := sqrt(jsd)]
```

David-style divergence matrices.
Dark on-diagonal squares represent occupation of stable states.
Most patients have distinct stable states.
```{r gordon-div-matrices,fig.width=7,fig.height=7}
setkey(gordon.div, subject.i, subject.j)
subjects <- sort(subjects)
names(subjects) <- subjects
gordon.div[, ":=" (hour.i = as.character(hour.i), hour.j = as.character(hour.j))]
plots <- lapply(subjects, function(subj) {
  sd <- gordon.div[.(subj, subj)]
  ts <- as.numeric(unique(sd$hour.i))
  lims <- as.character(sort(ts))
  p <- ggplot(sd, aes(x = hour.i, y = hour.j)) +
    geom_tile(aes(fill = jsd)) +
    scale_x_discrete(limits = lims) +
    scale_y_discrete(limits = lims) +
    theme(aspect.ratio = 1,
          axis.text = element_blank(),
          axis.ticks = element_blank())
})
plot_grid(plotlist = plots, ncol = 2, labels = names(plots), align = "hv")
```

Time-lag divergences:
```{r gordon-lag-jsd}
gordon.div[, delta.t := as.numeric(hour.j) - as.numeric(hour.i)]
plots <- lapply(subjects, function(subj) {
  sd <- gordon.div[.(subj, subj)]
  sd <- sd[delta.t > 0]
  p <- ggplot(sd, aes(x = delta.t, y = jsd)) +
    geom_point(size = 0.1) +
    geom_smooth(color = "blue") +
    scale_x_log10() +
    labs(x = "lag (hours)")
  p
})
plot_grid(plotlist = plots, align = "hv", labels = names(plots),
          nrow = 3)
```

Distributions of divergences show that for all patients, diarrhea and recovery states are more similar to themselves than to each other (cross-state divergences are large).
In most patients (except E) the recovery microbiome is actually less stable than the diarrhea microbiome: the diarrhea divergences tend to be smaller.
**However** this could also be due to the denser temporal sampling during the diarrhea period.
We should scale this by the time interval somehow, since it varies.
```{r gordon-dist-distrib}
gordon.div[, state := {
  if (state.i == state.j) state.i
  else "cross"
}, by = .(state.i, state.j)]  
p0 <- gordon.div[(subject.i == subject.j) & (delta.t > 0)] %>% 
  ggplot(aes(x = distance))
cdf <- p0 + stat_ecdf(aes(color = state)) + facet_wrap(~ subject.i, nrow = 1) + 
  labs(y = "ECDF") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
dens <- p0 + stat_density(aes(fill = state), alpha = 0.3,
                          position = "identity")
dens <- dens +
  facet_wrap(~ subject.i, nrow = 1) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
plot_grid(cdf, dens, nrow = 2, align = "v")
```

### Paths
MDS of all subjects simultaneously shows that diarrhea/recovery separates time points more than subject.
```{r gordon-paths}
setkey(gordon.div, subject.i, subject.j)
setkey(gordon.samples, subject)
edges <- lapply(subjects, function(subj) {
  sd <- gordon.div[.(subj, subj)]
  ts <- as.numeric(unique(sd$hour.i))
  ts <- as.character(sort(ts))
  ej <- data.table(ti = ts[-length(ts)], tj = ts[-1])
  samps <- gordon.samples[subj, .(sample, hour)]
  samps[, hour := as.character(hour)]
  ej <- merge(ej, samps, by.x = "ti", by.y = "hour")
  ej <- merge(ej, samps, by.x = "tj", by.y = "hour", suffixes = c(".i", ".j"))
  ej[, .(sample.i, sample.j)]
}) %>% rbindlist()
graf <- graph_from_data_frame(edges,
                              directed = TRUE, vertices = gordon.samples)
dm <- MakeDistMatrix(gordon.div, "sample.i", "sample.j")
fit <- CoordCMDS(dm)
xform <- fit$points
# order
setkey(xform, sample)
xform <- xform[V(graf)$name]
lo <- create_layout(graf, "manual", node.positions = xform)
ggraph(lo) +
  geom_edge_link(arrow = arrow(type = "closed", length = unit(3, "points")),
                 edge_width = 0.2, end_cap = square(length = 3,
                                                    unit = "points")) +
  geom_node_point(aes(color = state)) +
  # scale_shape_manual(values = seq(1, length(subjects))) +
  facet_nodes(~ subject, nrow = 2) +
  theme_graph(base_family = "Helvetica") +
  theme(aspect.ratio = 1)
ggplot(fit$eigrank, aes(x = rank, y = value ^ 2)) +
  geom_point() 
```

All points plot show recovery and diarrhea cluster separately for all patients, with diarrhea having greater spread:
```{r}
ggraph(lo) +
  geom_node_point(aes(color = state, shape = subject)) +
  scale_shape_manual(values = seq(uniqueN(gordon.samples$subject))) +
  theme_graph(base_family = "Helvetica") +
  theme(aspect.ratio = 1)
```

### Tree

All together.
Again separation is mostly diarrhea/recovery.
However, some diarrhea points are closer to recovery points than they are to the majority of diarrhea points.
This can also be seen in the last plot where the two 'clouds' enmesh.
```{r,fig.width=7,fig.height=7}
dm <- dcast(gordon.div, sample.i ~ sample.j, value.var = "distance")
rn <- dm[, sample.i] 
dm <- as.matrix(dm[, -1])
rownames(dm) <- rn
dendro <- as.dendrogram(hclust(dist(dm)))
# annotate
setkey(gordon.samples, sample)
dendro <- dendrapply(dendro, function(d) {
  if (is.leaf(d)) {
    samp.id <- attr(d, "label")
    sample <- gordon.samples[samp.id]
    subj <- sample$subject
    state <- sample$state
    attr(d, "nodePar") <- append(attr(d, "nodePar"), list(subject = subj,
                                                          state = state))
  }
  d
})
lo <- create_layout(dendro, "dendrogram", circular = TRUE)
ggraph(lo) +
  geom_edge_elbow() +
  geom_node_point(aes(filter = leaf, shape = subject, color = state)) +
  scale_shape_manual(values = seq(1, length(subjects))) +
  theme_graph(base_family = "Helvetica") +
  theme(aspect.ratio = 1)
```

```{r gordon-state-clusters,fig.width=7,fig.height=10}
setkey(gordon.div, subject.i, subject.j)
gordon.samples[, hour := as.character(hour)]
setkey(gordon.samples, subject, hour)
trees <- lapply(subjects, function(subj) {
  sd <- gordon.div[.(subj, subj)]
  sd <- dcast(sd, hour.i ~ hour.j, value.var = "distance")
  rn <- sd[, hour.i]
  dm <- as.matrix(sd[, -1])
  rownames(dm) <- rn
  dendro <- as.dendrogram(hclust(dist(dm)))
  # merge time data and state
  sd[, time.index := frank(as.numeric(hour.i))]
  setkey(sd, hour.i)
  dendro <- dendrapply(dendro, function(node) {
    if (is.leaf(node)) {
      labl <- attr(node, "label")
      t <- as.numeric(labl)
      time.index <- as.numeric(sd[labl, time.index])
      state <- gordon.samples[.(subj, labl), state]
      attr(node, "nodePar") <- append(attr(node, "nodePar"), 
                                      list(hour = t, time.index = time.index,
                                           state = state)
                                      )
    }
    node
  })
  # propagate state upwards through branch nodes
  dendro <- tree_apply(dendro, function(node, tree, depth, children) {
    if (!is.leaf(node)) {
      child.states <- sapply(children, function(n) {
        attr(n, "nodePar")$state
      }) %>% unique()
      if (length(child.states) == 1 & !anyNA(child.states)) {
        state <- child.states
      } else {
        state <- NA
      }
      attr(node, "nodePar") <- append(attr(node, "nodePar"),
                                      list(state = state))
    }
    node
  }, direction = "up")
  # browser()
  p <- ggraph(dendro, "dendrogram", circular = TRUE) +
    geom_edge_elbow(aes(color = node2.state)) +
    geom_node_point(aes(filter = leaf, color = time.index)) +
    scale_color_distiller(palette = "YlOrRd") +
    theme_graph(base_family = "Helvetica") +
    theme(aspect.ratio = 1, legend.key.height = unit(10, "points"))
})
plot_grid(plotlist = trees, ncol = 2, labels = names(trees))
```