---
title: "Decomposition of states and time scales in human microbiomes recovering from cholera"
output: html_notebook
---

```{r setup}
library(dplyr)
library(data.table)
library(cowplot)
library(ggraph)
library(igraph)
library(infograf)

source("~/github_bitbucket/wkc.r-utils/num_2_fac.R")

source("load_cholera_data.R")
gordon.jsds <- fread("jsds/cholera.txt")
gordon.jsds[, distance := sqrt(jsd)]
```

David-style divergence matrices.
Dark on-diagonal squares represent occupation of stable states.
Most patients have distinct stable states.
```{r gordon-div-matrices,fig.width=7,fig.height=7}
setkey(gordon.jsds, subject.i, subject.j)
subjects <- sort(unique(gordon.jsds[, subject.i]))
names(subjects) <- subjects
plots <- lapply(subjects, function(subj) {
  sd <- gordon.jsds[.(subj, subj)]
  p <- ggplot(sd, aes(x = num_2_fac(hour.i), y = num_2_fac(hour.j))) +
    geom_tile(aes(fill = jsd)) +
    labs(x = "time", y = "time") +
    theme(aspect.ratio = 1,
          axis.text = element_blank(),
          axis.ticks = element_blank())
})
plot_grid(plotlist = plots, ncol = 2, labels = names(plots), align = "hv")
```

Time-lag divergences:
```{r gordon-lag-jsd}
gordon.jsds[, delta.t := hour.j - hour.i]
plots <- lapply(subjects, function(subj) {
  sd <- gordon.jsds[.(subj, subj)]
  sd <- sd[delta.t > 0]
  p <- ggplot(sd, aes(x = delta.t, y = jsd)) +
    geom_point(size = 0.1) +
    geom_smooth(color = "blue") +
    scale_x_log10() +
    labs(x = "lag (hours)")
  p
})
plot_grid(plotlist = plots, align = "hv", labels = names(plots),
          nrow = 3)
```

Distributions of divergences show that for all patients, diarrhea and recovery states are more similar to themselves than to each other (cross-state divergences are large).
In most patients (except E) the recovery microbiome is actually less stable than the diarrhea microbiome: the diarrhea divergences tend to be smaller.
**However** this could also be due to the denser temporal sampling during the diarrhea period.
```{r gordon-dist-distrib,fig.asp=1}
gordon.jsds[, state := {
  if (state.i == state.j) state.i
  else "cross"
}, by = .(state.i, state.j)]  
gordon.jsds[(subject.i == subject.j) & (delta.t > 0)] %>% 
  ggplot(aes(x = subject.i, y = jsd)) +
  stat_boxplot(aes(color = state)) + coord_flip() +
  labs(x = "subject")
```

### Paths
MDS of all subjects simultaneously shows that diarrhea/recovery separates time points more than subject.
```{r gordon-paths}
setkey(gordon.jsds, subject.i, subject.j)
gordon.jsds[, c("sample.i", "sample.j") := lapply(list(
  list(subj = subject.i, state = state.i, hour = hour.i),
  list(subj = subject.j, state = state.j, hour = hour.j)), function(ll) {
    paste(ll$subj, ll$state, ll$hour, sep = "_")
  })]
# sample order
gordon.jsds[, idx.i := as.numeric(num_2_fac(hour.i)), by = subject.i]
gordon.jsds[, idx.j := as.numeric(num_2_fac(hour.j)), by = subject.j]
gordon.jsds[, increment := idx.j - idx.i]
edges <- gordon.jsds[subject.i == subject.j & increment == 1]
setcolorder(edges, c("sample.i", "sample.j", 
                     names(edges)[!grepl("sample", names(edges))]))
graf <- graph_from_data_frame(edges,
                              directed = TRUE, 
                              vertices = unique(gordon[, .(sample, 
                                                           subject, 
                                                           state, 
                                                           id, 
                                                           hour)]))
dm <- MakeDistMatrix(gordon.jsds, "sample.i", "sample.j")
fit <- CoordCMDS(dm)
xform <- fit$points %>% 
  as.data.table
# order
setkey(xform, sample)
xform <- xform[V(graf)$name]
```
```{r,fig.asp=1}
ggraph(graf, "manual", node.positions = xform) +
  geom_edge_link(arrow = arrow(length = unit(3, "points")),
                 edge_width = 0.2, 
                 end_cap = square(length = 3, unit = "points")) +
  geom_node_point(aes(color = state)) +
  facet_nodes(~ subject) +
  theme_graph(base_family = "Helvetica") +
  theme(aspect.ratio = 1)
```
```{r}
ggplot(fit$eigrank, aes(x = rank, y = value ^ 2)) +
  geom_point() 
```

All points plot show recovery and diarrhea cluster separately for all patients, with diarrhea having greater spread:
```{r}
ggraph(graf, "manual", node.positions = xform) +
  geom_density_2d(aes(x = x, y = y), data = xform, color = "grey80") +
  geom_node_point(aes(color = state, shape = subject)) +
  scale_shape_manual(values = seq(uniqueN(gordon$subject))) +
  theme_graph(base_family = "Helvetica") +
  theme(aspect.ratio = 1)
```

No clear separation of subjects within states with this projection:
```{r}
ggraph(graf, "manual", node.positions = xform) +
  geom_node_point(aes(color = subject)) +
  scale_shape_manual(values = seq(uniqueN(gordon$subject))) +
  facet_wrap(~ state) +
  theme_graph(base_family = "Helvetica") +
  theme(aspect.ratio = 1)
```

### Louvain clustering
```{r}
clusters <- gordon.jsds[, .(sample.i, sample.j, weight = 1 - jsd)] %>% 
  graph_from_data_frame(directed = FALSE) %>% 
  igraph::simplify(remove.loops = FALSE, edge.attr.comb = "first") %>% 
  cluster_louvain
V(graf)$cluster <- membership(clusters)[V(graf)$name]
ggraph(graf, "manual", node.positions = xform) +
  geom_density_2d(aes(x = x, y = y), data = xform, color = "grey80") +
  geom_node_point(aes(color = num_2_fac(cluster), shape = subject)) +
  labs(color = "cluster") +
  scale_shape_manual(values = seq(uniqueN(gordon$subject))) +
  theme_graph(base_family = "Helvetica") +
  theme(aspect.ratio = 1)
```

```{r}
ggraph(graf, "manual", node.positions = xform) +
  geom_edge_link(arrow = arrow(length = unit(3, "points")),
                 edge_width = 0.2, 
                 end_cap = square(length = 3, unit = "points")) +
  geom_node_point(aes(color = num_2_fac(cluster), shape = state)) +
  facet_nodes(~ subject) +
  labs(color = "cluster") +
  theme_graph(base_family = "Helvetica") +
  theme(aspect.ratio = 1)
```

```{r}
gordon[, idx := as.numeric(num_2_fac(hour)), by = subject]
gordon[, .(sample, subject, idx, state)] %>% 
  unique %>% 
  .[, cluster := membership(clusters)[sample]] %>% 
  ggplot(aes(x = idx, y = num_2_fac(cluster), color = state)) +
  geom_point(size = 0.5) +
  geom_line(aes(group = subject)) +
  labs(y = "cluster") +
  facet_wrap(~ subject, scales = "free_x")
```

## Density clustering
```{r}
library(dbscan)
mp <- 3 # min pts should be # dims + 1
kNNdistplot(xform[, .(x, y)], mp) # identifies knee at y ~ 0.4 for eps value
```

```{r}
xform[, dclust := dbscan(cbind(x, y), 0.4, mp)$cluster]
xform[dclust == 0, dclust := NA]
setkey(xform, sample)
vertex.attributes(graf)$dclust <- num_2_fac(xform[V(graf)$name, dclust])
lo <- create_layout(graf, "manual", node.positions = xform[, .(x, y)])
plot_paths_with_var("dclust", lo) 
```

### Tree

All together.
Again separation is mostly diarrhea/recovery.
However, some diarrhea points are closer to recovery points than they are to the majority of diarrhea points.
This can also be seen in the last plot where the two 'clouds' enmesh.
```{r,fig.width=7,fig.height=7,include=FALSE,eval=FALSE}
dm <- dcast(gordon.jsds, sample.i ~ sample.j, value.var = "distance")
rn <- dm[, sample.i] 
dm <- as.matrix(dm[, -1])
rownames(dm) <- rn
dendro <- as.dendrogram(hclust(dist(dm)))
# annotate
setkey(gordon.samples, sample)
dendro <- dendrapply(dendro, function(d) {
  if (is.leaf(d)) {
    samp.id <- attr(d, "label")
    sample <- gordon.samples[samp.id]
    subj <- sample$subject
    state <- sample$state
    attr(d, "nodePar") <- append(attr(d, "nodePar"), list(subject = subj,
                                                          state = state))
  }
  d
})
lo <- create_layout(dendro, "dendrogram", circular = TRUE)
ggraph(lo) +
  geom_edge_elbow() +
  geom_node_point(aes(filter = leaf, shape = subject, color = state)) +
  scale_shape_manual(values = seq(1, length(subjects))) +
  theme_graph(base_family = "Helvetica") +
  theme(aspect.ratio = 1)
```

```{r gordon-state-clusters,fig.width=7,fig.height=10,include=FALSE,eval=FALSE}
setkey(gordon.jsds, subject.i, subject.j)
gordon.samples[, hour := as.character(hour)]
setkey(gordon.samples, subject, hour)
trees <- lapply(subjects, function(subj) {
  sd <- gordon.jsds[.(subj, subj)]
  sd <- dcast(sd, hour.i ~ hour.j, value.var = "distance")
  rn <- sd[, hour.i]
  dm <- as.matrix(sd[, -1])
  rownames(dm) <- rn
  dendro <- as.dendrogram(hclust(dist(dm)))
  # merge time data and state
  sd[, time.index := frank(as.numeric(hour.i))]
  setkey(sd, hour.i)
  dendro <- dendrapply(dendro, function(node) {
    if (is.leaf(node)) {
      labl <- attr(node, "label")
      t <- as.numeric(labl)
      time.index <- as.numeric(sd[labl, time.index])
      state <- gordon.samples[.(subj, labl), state]
      attr(node, "nodePar") <- append(attr(node, "nodePar"), 
                                      list(hour = t, time.index = time.index,
                                           state = state)
                                      )
    }
    node
  })
  # propagate state upwards through branch nodes
  dendro <- tree_apply(dendro, function(node, tree, depth, children) {
    if (!is.leaf(node)) {
      child.states <- sapply(children, function(n) {
        attr(n, "nodePar")$state
      }) %>% unique()
      if (length(child.states) == 1 & !anyNA(child.states)) {
        state <- child.states
      } else {
        state <- NA
      }
      attr(node, "nodePar") <- append(attr(node, "nodePar"),
                                      list(state = state))
    }
    node
  }, direction = "up")
  # browser()
  p <- ggraph(dendro, "dendrogram", circular = TRUE) +
    geom_edge_elbow(aes(color = node2.state)) +
    geom_node_point(aes(filter = leaf, color = time.index)) +
    scale_color_distiller(palette = "YlOrRd") +
    theme_graph(base_family = "Helvetica") +
    theme(aspect.ratio = 1, legend.key.height = unit(10, "points"))
})
plot_grid(plotlist = trees, ncol = 2, labels = names(trees))
```